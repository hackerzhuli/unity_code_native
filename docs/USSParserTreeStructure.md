# USS Parser Tree Structure

This document describes the syntax tree structure generated by the USS parser using tree-sitter-css. Understanding this structure is essential for developing language server features like semantic highlighting, code completion, and diagnostics.

## Overview

The USS parser uses the tree-sitter-css grammar since USS (Unity Style Sheets) syntax is nearly identical to CSS. The parser generates a hierarchical syntax tree where each node represents a syntactic element.

### Sample Analysis

Based on analysis of `examples/sample.uss` (120 lines, 3,847 bytes), the parser generates:
- **16 rule sets** with various selector types
- **57 declarations** covering Unity-specific and standard CSS properties
- **13 comments** for documentation
- **8 function calls** including `resource()`, `url()`, `var()`, and `rgba()`
- **1 import statement** for modular stylesheets

### Node Distribution
The most common node types in a typical USS file:
- `declaration` (57) - Property-value pairs
- `:` (61) - Colon separators
- `;` (58) - Statement terminators
- `property_name` (57) - CSS/Unity property names
- `integer_value` (27) - Numeric values with units
- `rule_set` (16) - Complete CSS rules
- `block` (16) - Declaration blocks
- `selectors` (16) - Selector groups

## Basic Tree Structure

### Root Node
- **Type**: `stylesheet`
- **Description**: The root node of any USS document
- **Children**: Contains one or more rule sets, at-rules, or comments

### Rule Set Structure
```
stylesheet
└── rule_set
    ├── selectors
    │   └── [selector_type]
    └── block
        ├── "{" (opening brace)
        ├── declaration
        │   ├── property_name
        │   ├── ":" (colon)
        │   └── [value_type]
        ├── ";" (semicolon)
        └── "}" (closing brace)
```

## Selector Types

### Class Selector
- **Type**: `class_selector`
- **Structure**:
  ```
  class_selector
  ├── "." (dot token)
  └── class_name
  ```
- **Example**: `.my-class`

### Type Selector (Tag Name)
- **Type**: `tag_name`
- **Description**: Selects elements by their type (e.g., Button, Label)
- **Example**: `Button`

### ID Selector
- **Type**: `id_selector`
- **Structure**:
  ```
  id_selector
  ├── "#" (hash token)
  └── id_name
  ```
- **Example**: `#my-id`

### Pseudo-class Selector
- **Type**: `pseudo_class_selector`
- **Description**: Selects elements in specific states
- **Example**: `:hover`, `:active`, `:focus`

### Complex Selectors
Complex selectors combine multiple selector types:
```
selectors
└── [multiple selector nodes in sequence]
    ├── tag_name ("Button")
    ├── class_selector (".primary")
    └── pseudo_class_selector (":hover")
```

## Declaration Structure

### Basic Declaration
```
declaration
├── property_name
├── ":" (colon)
└── [value_type]
```

### Value Types

#### Plain Value
- **Type**: `plain_value`
- **Description**: Simple text values
- **Example**: `red`, `bold`, `center`

#### Numeric Values
- **Type**: `integer_value` or `float_value`
- **Description**: Numeric values with optional units
- **Example**: `10px`, `1.5em`, `100%`

#### String Value
- **Type**: `string_value`
- **Description**: Quoted string literals
- **Example**: `"Arial"`, `'Helvetica'`

#### Color Value
- **Type**: `color_value`
- **Description**: Color values in various formats
- **Example**: `#ff0000`, `rgb(255, 0, 0)`, `rgba(255, 0, 0, 0.5)`

#### Function Calls
- **Type**: `call_expression`
- **Structure**:
  ```
  call_expression
  ├── function_name
  └── arguments
      └── [argument values]
  ```
- **Example**: `resource("Arial")`, `url("image.png")`

## Unity-Specific Properties

Unity-specific properties follow the same declaration structure but use Unity-specific property names:

### Examples
- `-unity-font`: Font resource references
- `-unity-background-image-tint-color`: Background image tinting
- `-unity-slice-left`, `-unity-slice-right`: 9-slice sprite properties
- `flex-direction`, `justify-content`: Flexbox layout properties

### Resource Function Calls
```
declaration
├── property_name ("-unity-font")
├── ":"
└── call_expression
    ├── function_name ("resource")
    └── arguments
        └── string_value ("\"Arial\"")
```

## Comments
- **Type**: `comment`
- **Description**: CSS-style comments
- **Example**: `/* This is a comment */`

## At-Rules
- **Type**: `at_rule`
- **Description**: CSS at-rules (though rarely used in USS)
- **Example**: `@import`, `@media`

### Import Statements
- **Type**: `import_statement`
- **Structure**:
  ```
  import_statement
  ├── @import
  └── string_value ("common-styles.uss")
  ```
- **Example**: `@import "common-styles.uss";`

## Real-World Examples from Sample File

### CSS Variables (Custom Properties)
```
rule_set[8:1]
├── selectors[8:1]
│   └── pseudo_class_selector[8:1] ":root"
└── block[8:7]
    ├── "{"[8:7]
    ├── declaration[9:5] "--primary-color: #3498db;"
    │   ├── property_name[9:5] "--primary-color"
    │   ├── ":"[9:20]
    │   └── color_value[9:22] "#3498db"
    ├── ";"[9:29]
    └── "}"[12:1]
```

### Complex Selectors with Pseudo-classes
```
rule_set[45:1]
├── selectors[45:1]
│   ├── tag_name[45:1] "Button"
│   └── pseudo_class_selector[45:7] ":hover"
└── block[45:13]
    ├── declaration[46:5] "background-color: #2980b9;"
    │   ├── property_name[46:5] "background-color"
    │   ├── ":"[46:21]
    │   └── color_value[46:23] "#2980b9"
    └── declaration[48:5] "scale: 1.05 1.05;"
        ├── property_name[48:5] "scale"
        ├── ":"[48:10]
        ├── float_value[48:12] "1.05"
        └── float_value[48:17] "1.05"
```

### Unity Resource Function Calls
```
declaration[20:5]
├── property_name[20:5] "-unity-font"
├── ":"[20:17]
└── call_expression[20:19]
    ├── function_name[20:19] "resource"
    └── arguments[20:27]
        └── string_value[20:28] "\"Arial\""
```

### CSS Variable References
```
declaration[16:5]
├── property_name[16:5] "background-color"
├── ":"[16:21]
└── call_expression[16:23]
    ├── function_name[16:23] "var"
    └── arguments[16:26]
        └── plain_value[16:27] "--primary-color"
```

### Child Combinator Selectors
```
rule_set[60:1]
├── selectors[60:1]
│   ├── class_selector[60:1] ".dialog-box"
│   ├── child_selector[60:13] ">"
│   └── tag_name[60:15] "Button"
└── block[60:22]
    └── declaration[61:5] "margin-bottom: 8px;"
```

### Multiple Selectors
```
rule_set[69:1]
├── selectors[69:1]
│   ├── tag_name[69:1] "Label"
│   ├── ","[69:6]
│   └── tag_name[69:8] "TextField"
└── block[69:18]
    ├── declaration[70:5] "color: #2c3e50;"
    └── declaration[71:5] "font-size: 14px;"
```

### Descendant Combinator Selectors
```
rule_set[64:1]
├── selectors[64:1]
│   ├── class_selector[64:1] ".toolbar"
│   ├── descendant_selector[64:9] " "
│   └── class_selector[64:10] ".icon-button"
└── block[64:23]
    ├── declaration[65:5] "width: 32px;"
    ├── declaration[66:5] "height: 32px;"
    └── declaration[67:5] "background-image: url(\"icons/default.png\");"
```

### Numeric Values with Units
```
declaration[65:5]
├── property_name[65:5] "width"
├── ":"[65:10]
└── integer_value[65:12] "32px"
    └── unit[65:14] "px"
```

### RGBA Color Functions
```
declaration[10:5]
├── property_name[10:5] "--secondary-color"
├── ":"[10:22]
└── call_expression[10:24]
    ├── function_name[10:24] "rgba"
    └── arguments[10:28]
        ├── integer_value[10:29] "52"
        ├── ","[10:31]
        ├── integer_value[10:33] "152"
        ├── ","[10:36]
        ├── integer_value[10:38] "219"
        ├── ","[10:41]
        └── float_value[10:43] "0.8"
```

## Error Handling

### Error Detection
- Use `node.has_error()` to check if a node contains parsing errors
- Error nodes indicate syntax issues that should be reported as diagnostics

### Missing Nodes
- Some nodes may be missing in malformed USS
- Always check for `None` when accessing child nodes
- Use `node.child_by_field_name()` for reliable field access

## Practical Usage Examples

### Walking the Tree
```rust
fn walk_tree(node: tree_sitter::Node, content: &str) {
    println!("Node: {} - Text: {}", 
        node.kind(), 
        node.utf8_text(content.as_bytes()).unwrap_or("<invalid>")
    );
    
    for i in 0..node.child_count() {
        if let Some(child) = node.child(i) {
            walk_tree(child, content);
        }
    }
}
```

### Finding Specific Nodes
```rust
fn find_declarations(node: tree_sitter::Node) -> Vec<tree_sitter::Node> {
    let mut declarations = Vec::new();
    
    if node.kind() == "declaration" {
        declarations.push(node);
    }
    
    for i in 0..node.child_count() {
        if let Some(child) = node.child(i) {
            declarations.extend(find_declarations(child));
        }
    }
    
    declarations
}
```

### Extracting Property-Value Pairs
```rust
fn extract_property_value(declaration: tree_sitter::Node, content: &str) -> Option<(String, String)> {
    let property = declaration.child(0)?; // property_name
    let value = declaration.child(2)?;    // value (skip colon)
    
    let property_text = property.utf8_text(content.as_bytes()).ok()?;
    let value_text = value.utf8_text(content.as_bytes()).ok()?;
    
    Some((property_text.to_string(), value_text.to_string()))
}
```

## Language Server Integration

### Semantic Token Mapping
Map tree-sitter node types to LSP semantic token types:
- `class_selector` → `SemanticTokenType::CLASS`
- `tag_name` → `SemanticTokenType::TYPE`
- `property_name` → `SemanticTokenType::PROPERTY`
- `plain_value`, `integer_value`, `float_value` → `SemanticTokenType::NUMBER`
- `string_value` → `SemanticTokenType::STRING`
- `comment` → `SemanticTokenType::COMMENT`
- `pseudo_class_selector` → `SemanticTokenType::MODIFIER`
- `function_name` → `SemanticTokenType::FUNCTION`
- `color_value` → `SemanticTokenType::NUMBER`
- `id_selector` → `SemanticTokenType::VARIABLE`

### Advanced Token Classification
Based on sample file analysis, consider these patterns:
- **Unity Properties**: Properties starting with `-unity-` should be highlighted as Unity-specific
- **CSS Variables**: Properties starting with `--` are custom properties
- **Function Calls**: `resource()`, `url()`, `var()`, `rgba()` functions
- **Combinators**: `>` (child), ` ` (descendant), `,` (multiple selectors)
- **Units**: `px`, `em`, `%`, `deg` attached to numeric values

### Diagnostic Generation
- Check for `has_error()` on nodes
- Validate Unity-specific property names (must start with `-unity-`)
- Verify value types match property expectations
- Report missing semicolons or braces
- Validate function arguments (e.g., `resource()` should have string argument)
- Check for valid CSS variable references in `var()` functions

### Code Completion Context Detection
```rust
fn get_completion_context(node: tree_sitter::Node, cursor_position: usize) -> CompletionContext {
    match node.kind() {
        "selectors" => CompletionContext::Selector,
        "property_name" => CompletionContext::Property,
        "arguments" if parent_is_function(node) => CompletionContext::FunctionArgument,
        "plain_value" | "string_value" => CompletionContext::PropertyValue,
        _ => CompletionContext::Unknown,
    }
}
```

### Code Completion Suggestions
- **Selector context**: Unity UI element types (`Button`, `Label`, `TextField`, etc.)
- **Property context**: Unity-specific properties (`-unity-font`, `-unity-background-scale-mode`, etc.)
- **Value context**: 
  - For `-unity-font`: `resource("font-name")`
  - For `background-image`: `url("path")` or `resource("asset")`
  - For colors: hex values, `rgba()`, CSS color names
  - For layout: `flex`, `none`, `auto`

## Performance Considerations

- Tree-sitter parsing is fast and incremental
- Cache parsed trees for unchanged documents
- Use `old_tree` parameter for incremental parsing
- Avoid deep tree traversals in hot paths
- Consider using tree queries for complex pattern matching

## Testing Tree Structure

When writing tests, verify:
1. **Root node is `stylesheet`** - Every USS file starts with this
2. **Rule sets have correct structure** - `selectors` + `block` children
3. **Selectors are parsed correctly** - Various types: `tag_name`, `class_selector`, `id_selector`, `pseudo_class_selector`
4. **Declarations contain expected property-value pairs** - `property_name` + `:` + value + `;`
5. **Unity-specific syntax is recognized** - Properties with `-unity-` prefix
6. **Error nodes are properly detected** - Use `has_error()` method
7. **Function calls are structured correctly** - `call_expression` with `function_name` + `arguments`
8. **Combinators work properly** - `child_selector` (`>`), `descendant_selector` (space)
9. **Multiple selectors are comma-separated** - Check for `,` tokens between selectors
10. **Units are attached to numeric values** - `integer_value`/`float_value` with `unit` child

### Sample Test Cases
```rust
#[test]
fn test_unity_property_parsing() {
    let content = "Button { -unity-font: resource(\"Arial\"); }";
    // Verify: tag_name → property_name → call_expression → function_name + arguments
}

#[test]
fn test_complex_selector_parsing() {
    let content = "Button.primary:hover { color: red; }";
    // Verify: tag_name + class_selector + pseudo_class_selector
}

#[test]
fn test_css_variable_parsing() {
    let content = ":root { --color: #fff; } .test { color: var(--color); }";
    // Verify: custom property declaration + var() function call
}

#[test]
fn test_combinator_parsing() {
    let content = ".parent > .child { margin: 0; }";
    // Verify: class_selector + child_selector + class_selector
}
```

### Tree Dumper Utility

Use the provided `tree_dumper.rs` example to analyze new USS constructs:
```bash
cargo run --example tree_dumper examples/sample.uss
```

This will output the complete syntax tree with node positions and statistics, helping you understand how new USS features are parsed.

## Maintenance Notes

This structure documentation should be updated when:
- New USS features are added to Unity
- The underlying tree-sitter-css grammar changes
- New Unity-specific properties are introduced
- CSS specification updates affect USS parsing

Run the tree dumper on comprehensive USS samples to ensure the documentation remains accurate and complete.